<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Using IRAM.jl · IRAM.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IRAM.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Theory</span><ul><li><a class="toctext" href="../theory/transformations.html">Eigenvalue problems</a></li><li><a class="toctext" href="../theory/partial_schur.html">Schur decomposition</a></li></ul></li><li class="current"><a class="toctext" href="usage.html">Using IRAM.jl</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Applying-shift-and-invert-to-target-smallest-eigenvalues-with-LinearMaps.jl-1">Applying shift-and-invert to target smallest eigenvalues with LinearMaps.jl</a></li><li class="toplevel"><a class="toctext" href="#Solving-a-generalized-eigenvalue-problem-targeting-smallest-eigenvalues-with-LinearMaps.jl-1">Solving a generalized eigenvalue problem targeting smallest eigenvalues with LinearMaps.jl</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="usage.html">Using IRAM.jl</a></li></ul><a class="edit-page" href="https://github.com/haampie/IRAM.jl/blob/master/docs/src/usage/usage.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Using IRAM.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Using-IRAM.jl-1" href="#Using-IRAM.jl-1">Using IRAM.jl</a></h1><p>You can compute the partial Schur form of a matrix with <code>partial_schur</code>:</p><p><code>partial_schur(A; min, max, nev, tol, maxiter, which)</code></p><p>where <code>A</code> is the <code>n</code>×<code>n</code> matrix whose eigenvalues and eigenvectors you want; <code>min</code> specifies the minimum dimension to which the Hessenberg matrix is reduced after <code>implicit_restart!</code>; <code>max</code> specifies the maximum dimension of the Hessenberg matrix at which point <code>iterate_arnoldi!</code> stops increasing the dimension of the Krylov subspace; <code>nev</code> specifies the minimum amount of eigenvalues the method gives you; <code>tol</code> specifies the criterion that determines when the eigenpairs are considered converged (in practice, smaller <code>tol</code> forces the eigenpairs to converge even more); <code>maxiter</code> specifies the maximum amount of restarts the method can perform before ending the iteration; and <code>which</code> is a <code>Target</code> structure and specifies which eigenvalues are desired (Largest magnitude, smallest real part, etc.).</p><p>The function call <code>partial_schur</code> returns a tuple (<code>P</code>,<code>prods</code>), where <code>P</code> is a <code>PartialSchur</code> struct with fields <code>Q</code> and <code>R</code> for which <code>A * P.Q ≈ P.Q * P.R</code>. The upper triangular matrix <code>R</code> is of size <code>nev</code>×<code>nev</code> and the unitary matrix <code>Q</code> is of size <code>n</code>×<code>nev</code>. The amount of matrix-vector products computed during the iterations is stored in <code>prods</code>.</p><p>You can compute the eigenvalues and eigenvectors from the Schur form with <code>schur_to_eigen</code>:</p><p><code>schur_to_eigen(P)</code></p><p>where <code>P</code> is a <code>PartialSchur</code> struct that contains the partial Schur decomposition of a matrix <code>A</code>. This computes the eigenvalues and eigenvectors of matrix <code>A</code> from the Schur decomposition <code>P</code>.</p><p>An example of how to use IRAM.jl&#39;s function <code>partial_schur</code>:</p><pre><code class="language-none">julia&gt; using IRAM, LinearAlgebra
# Generate a sparse matrix
julia&gt; A = spdiagm(-1 =&gt; fill(-1.0, 99), 0 =&gt; fill(2.0, 100), 1 =&gt; fill(-1.001, 99));
# Compute Schur form of A
julia&gt; schur_form,  = partial_schur(A, min = 12, max = 30, nev = 10, tol = 1e-10, maxiter = 20, which=LM());
julia&gt; Q,R = schur_form.Q, schur_form.R;
julia&gt; norm(A*Q - Q*R)
6.336794280593682e-11
# Compute eigenvalues and eigenvectors of A
julia&gt; vals, vecs = schur_to_eigen(schur_form);
# Show that Ax = λx
julia&gt; norm(A*vecs - vecs*Diagonal(vals))
6.335460143979987e-11</code></pre><h1><a class="nav-anchor" id="Applying-shift-and-invert-to-target-smallest-eigenvalues-with-LinearMaps.jl-1" href="#Applying-shift-and-invert-to-target-smallest-eigenvalues-with-LinearMaps.jl-1">Applying shift-and-invert to target smallest eigenvalues with LinearMaps.jl</a></h1><pre><code class="language-none">using IRAM, LinearMaps

# Define a matrix whose eigenvalues you want
A = rand(100,100)

# Inverts the problem
function construct_linear_map(A)
    a = factorize(A)
    LinearMap{eltype(A)}((y, x) -&gt; ldiv!(y, a, x), size(A,1), ismutating=true)
end

# Target the largest eigenvalues of the inverted problem
schur_form,  = partial_schur(construct_linear_map(A), min=11, max=22, nev=10, tol=1e-5, maxiter=100, which=LM())
inv_vals, vecs = schur_to_eigen(schur_form)

# Eigenvalues have to be inverted to find the smallest eigenvalues of the non-inverted problem.
vals = ones(length(inv_vals))./inv_vals

# Show that Ax = λx
@assert norm(A*vecs - vecs*Diagonal(vals)) &lt; 1e-5</code></pre><h1><a class="nav-anchor" id="Solving-a-generalized-eigenvalue-problem-targeting-smallest-eigenvalues-with-LinearMaps.jl-1" href="#Solving-a-generalized-eigenvalue-problem-targeting-smallest-eigenvalues-with-LinearMaps.jl-1">Solving a generalized eigenvalue problem targeting smallest eigenvalues with LinearMaps.jl</a></h1><pre><code class="language-none">using IRAM, LinearMaps

# Define the matrices of the generalized eigenvalue problem
A, B = rand(100,100), rand(100,100)

struct ShiftAndInvert{TA,TB,TT}
    A_lu::TA
    B::TB
    temp::TT
end

function (M::ShiftAndInvert)(y,x)
    mul!(M.temp, M.B, x)
    ldiv!(y, M.A_lu, M.temp)
end

function construct_linear_map(A,B)
    a = ShiftAndInvert(factorize(A),B,Vector{eltype(A)}(undef, size(A,1)))
    LinearMap{eltype(A)}(a, size(A,1), ismutating=true)
end

# Target the largest eigenvalues of the inverted problem
schur_form,  = partial_schur(construct_linear_map(A,B), min=11, max=22, nev=10, tol=1e-5, maxiter=100, which=LM())
inv_vals, vecs = schur_to_eigen(schur_form)

# Eigenvalues have to be inverted to find the smallest eigenvalues of the non-inverted problem.
vals = ones(length(inv_vals))./inv_vals

# Show that Ax = λBx
@assert norm(A*vecs - B*vecs*Diagonal(vals)) &lt; 1e-5</code></pre><footer><hr/><a class="previous" href="../theory/partial_schur.html"><span class="direction">Previous</span><span class="title">Schur decomposition</span></a></footer></article></body></html>
