<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · ArnoldiMethod.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ArnoldiMethod.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="../theory.html">Theory</a></li><li><span class="toctext">Using ArnoldiMethod.jl</span><ul><li class="current"><a class="toctext" href="01_getting_started.html">Getting started</a><ul class="internal"><li><a class="toctext" href="#Installing-1">Installing</a></li><li><a class="toctext" href="#Construct-a-partial-Schur-decomposition-1">Construct a partial Schur decomposition</a></li><li><a class="toctext" href="#From-a-Schur-decomposition-to-an-eigendecomposition-1">From a Schur decomposition to an eigendecomposition</a></li><li><a class="toctext" href="#Example-1">Example</a></li></ul></li><li><a class="toctext" href="02_spectral_transformations.html">Transformations</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Using ArnoldiMethod.jl</li><li><a href="01_getting_started.html">Getting started</a></li></ul><a class="edit-page" href="https://github.com/haampie/ArnoldiMethod.jl/blob/master/docs/src/usage/01_getting_started.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Getting started</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="getting_started-1" href="#getting_started-1">Getting started</a></h1><h2><a class="nav-anchor" id="Installing-1" href="#Installing-1">Installing</a></h2><p>In Julia open the package manager in the REPL via <code>]</code> and run:</p><pre><code class="language-julia">(v1.0) pkg&gt; add git@github.com:haampie/ArnoldiMethod.jl.git</code></pre><p>Then use the package.</p><pre><code class="language-julia">using ArnoldiMethod</code></pre><h2><a class="nav-anchor" id="Construct-a-partial-Schur-decomposition-1" href="#Construct-a-partial-Schur-decomposition-1">Construct a partial Schur decomposition</a></h2><p>ArnoldiMethod.jl exports the <code>partialschur</code> function which can be used to  obtain a partial Schur decomposition of any matrix <code>A</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ArnoldiMethod.partialschur" href="#ArnoldiMethod.partialschur"><code>ArnoldiMethod.partialschur</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">partialschur(A; nev, which, tol, mindim, maxdim, restarts) -&gt; PartialSchur, History</code></pre><p>Find <code>nev</code> approximate eigenpairs of <code>A</code> with eigenvalues near a specified target.</p><p>The matrix <code>A</code> can be any linear map that implements <code>mul!(y, A, x)</code>, <code>eltype</code> and <code>size</code>.</p><p>The method will run iteratively until the eigenpairs are approximated to the prescribed tolerance or until <code>restarts</code> restarts have passed.</p><p><strong>Arguments</strong></p><p>The most important keyword arguments:</p><table><tr><th>Keyword</th><th>Type</th><th>Default</th><th>Description</th></tr><tr><td><code>nev</code></td><td><code>Int</code></td><td><code>min(6, size(A, 1))</code></td><td>Number of eigenvalues</td></tr><tr><td><code>which</code></td><td><code>Target</code></td><td><code>LM()</code></td><td>One of <code>LM()</code>, <code>LR()</code>, <code>SR()</code>, <code>LI()</code>, <code>SI()</code>, see below.</td></tr><tr><td><code>tol</code></td><td><code>Real</code></td><td><code>√eps</code></td><td>Tolerance for convergence: ‖Ax - xλ‖₂ &lt; tol * ‖λ‖</td></tr></table><p>The target <code>which</code> can be any of <code>subtypes(ArnoldiMethod.Target)</code>:</p><table><tr><th>Target</th><th>Description</th></tr><tr><td><code>LM()</code></td><td>Largest magnitude: <code>abs(λ)</code> is largest</td></tr><tr><td><code>LR()</code></td><td>Largest real part: <code>real(λ)</code> is largest</td></tr><tr><td><code>SR()</code></td><td>Smallest real part: <code>real(λ)</code> is smallest</td></tr><tr><td><code>LI()</code></td><td>Largest imaginary part: <code>imag(λ)</code> is largest</td></tr><tr><td><code>SI()</code></td><td>Smallest imaginary part: <code>imag(λ)</code> is smallest</td></tr></table><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The targets <code>LI()</code> and <code>SI()</code> only make sense in complex arithmetic. In real arithmetic <code>λ</code> is an eigenvalue iff <code>conj(λ)</code> is an eigenvalue and this  conjugate pair converges simultaneously.</p></div></div><p><strong>Return values</strong></p><p>The function returns a tuple</p><pre><code class="language-julia">decomp, history = partialschur(A, ...)</code></pre><p>where <code>decomp</code> is a <code>PartialSchur</code> struct which forms a partial Schur  decomposition of <code>A</code> to a prescribed tolerance:</p><pre><code class="language-julia">&gt; norm(A * decomp.Q - decomp.Q * decomp.R)</code></pre><p><code>history</code> is a <code>History</code> struct that holds some basic information about convergence of the method:</p><pre><code class="language-julia">&gt; history.converged
true
&gt; @show history
Converged after 359 matrix-vector products</code></pre><p><strong>Advanced usage</strong></p><p>Further there are advanced keyword arguments for tuning the algorithm:</p><table><tr><th>Keyword</th><th>Type</th><th>Default</th><th>Description</th></tr><tr><td><code>mindim</code></td><td><code>Int</code></td><td><code>min(max(10, nev), size(A,1))</code></td><td>Minimum Krylov dimension (≥ nev)</td></tr><tr><td><code>maxdim</code></td><td><code>Int</code></td><td><code>min(max(20, 2nev), size(A,1))</code></td><td>Maximum Krylov dimension (≥ min)</td></tr><tr><td><code>restarts</code></td><td><code>Int</code></td><td><code>200</code></td><td>Maximum number of restarts</td></tr></table><p>When the algorithm does not converge, one can increase <code>restarts</code>. When the  algorithm converges too slowly, one can play with <code>mindim</code> and <code>maxdim</code>. It is  suggested to keep <code>mindim</code> equal to or slightly larger than <code>nev</code>, and <code>maxdim</code> is usually about two times <code>mindim</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haampie/ArnoldiMethod.jl/blob/fa7e0ad1f44372054acb6e4d28bd70f47bb7391c/src/run.jl#L14-L93">source</a></section><h2><a class="nav-anchor" id="From-a-Schur-decomposition-to-an-eigendecomposition-1" href="#From-a-Schur-decomposition-to-an-eigendecomposition-1">From a Schur decomposition to an eigendecomposition</a></h2><p>The eigenvalues and eigenvectors are obtained from the Schur form with the  <code>partialeigen</code> function that is exported by ArnoldiMethod.jl:</p><pre><code class="language-julia">λs, X = partialeigen(decomp::PartialSchur)</code></pre><p>Note that whenever the matrix <code>A</code> is real-symmetric or Hermitian, the partial  Schur decomposition coincides with the partial eigendecomposition, so in that  case there is no need for the transformation.</p><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><p>Here we compute the first ten eigenvalues and eigenvectors of a tridiagonal sparse matrix.</p><pre><code class="language-julia">julia&gt; using ArnoldiMethod, LinearAlgebra, SparseArrays
julia&gt; A = spdiagm(
           -1 =&gt; fill(-1.0, 99),
            0 =&gt; fill(2.0, 100), 
            1 =&gt; fill(-1.0, 99)
       );
julia&gt; decomp, history = partialschur(A, nev=10, tol=1e-6, which=SR());
julia&gt; history
Converged after 178 matrix-vector products
julia&gt; norm(A * decomp.Q - decomp.Q * decomp.R)
3.717314639756976e-8
julia&gt; λs, X = partialeigen(decomp);
julia&gt; norm(A * X - X * Diagonal(λs))
3.7173146389810755e-8</code></pre><footer><hr/><a class="previous" href="../theory.html"><span class="direction">Previous</span><span class="title">Theory</span></a><a class="next" href="02_spectral_transformations.html"><span class="direction">Next</span><span class="title">Transformations</span></a></footer></article></body></html>
